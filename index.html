<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scaled Intimacy Simulation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            margin: 0;
            padding: 0;
            background: transparent;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 100%;
        }
        h1 {
            color: #333;
            margin-bottom: 8px;
            font-size: 24px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
            font-size: 13px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            color: #667eea;
            font-weight: bold;
            font-size: 14px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .viz-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
        }
        @media (min-width: 768px) {
            .viz-container {
                display: grid;
                grid-template-columns: 2fr 1fr;
            }
        }
        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
            max-width: 100%;
            height: auto;
        }
        .metrics {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .metric {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .metric-name {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-top: 5px;
        }
        .metric-desc {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }
        .phase-indicator {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 20px;
        }
        .phase-quiet {
            background: #e3f2fd;
            color: #1976d2;
        }
        .phase-loud {
            background: #fff3e0;
            color: #f57c00;
        }
        .chart-container {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê Scaled Intimacy Simulation</h1>
        <p class="subtitle">Agent-based model exploring presence capacity, reciprocity, vulnerability, and memory in social networks</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Agents (N): <span class="value-display" id="n-val">50</span></label>
                <input type="range" id="n-agents" min="20" max="100" value="50" step="10">
            </div>
            <div class="control-group">
                <label>Pod Size: <span class="value-display" id="pod-val">8</span></label>
                <input type="range" id="pod-size" min="5" max="15" value="8">
            </div>
            <div class="control-group">
                <label>Quiet Cycles (Q): <span class="value-display" id="q-val">10</span></label>
                <input type="range" id="q-cycles" min="5" max="20" value="10">
            </div>
            <div class="control-group">
                <label>Loud Cycles (L): <span class="value-display" id="l-val">4</span></label>
                <input type="range" id="l-cycles" min="2" max="10" value="4">
            </div>
        </div>

        <div style="text-align: center; margin-bottom: 20px;">
            <button id="start-btn" onclick="startSimulation()">‚ñ∂ Start Simulation</button>
            <button id="pause-btn" onclick="pauseSimulation()" disabled>‚è∏ Pause</button>
            <button onclick="resetSimulation()">üîÑ Reset</button>
        </div>

        <div id="phase-indicator" class="phase-indicator phase-quiet">
            Phase: QUIET (Cycle 0)
        </div>

        <div class="viz-container">
            <canvas id="network-canvas" width="600" height="600"></canvas>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-name">SII - Systemic Intimacy Index</div>
                    <div class="metric-value" id="sii-val">0.00</div>
                    <div class="metric-desc">Overall system health composite</div>
                </div>
                <div class="metric">
                    <div class="metric-name">PD - Presence Density</div>
                    <div class="metric-value" id="pd-val">0.0</div>
                    <div class="metric-desc">Avg meaningful ties per agent</div>
                </div>
                <div class="metric">
                    <div class="metric-name">RI - Reciprocity Index</div>
                    <div class="metric-value" id="ri-val">0.00</div>
                    <div class="metric-desc">Completed interaction loops</div>
                </div>
                <div class="metric">
                    <div class="metric-name">MR - Memory Retention</div>
                    <div class="metric-value" id="mr-val">0.00</div>
                    <div class="metric-desc">Avg trace strength</div>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h3 style="margin-top: 0;">SII Over Time</h3>
            <canvas id="chart-canvas" width="1200" height="200"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #667eea;"></div>
                    <span>Quiet Phase</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f57c00;"></div>
                    <span>Loud Phase</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simulation state
        let agents = [];
        let edges = [];
        let pods = [];
        let cycle = 0;
        let running = false;
        let animationId = null;
        let history = [];

        // Parameters
        let N = 50;
        let podSize = 8;
        let Q = 10;
        let L = 4;

        // Update slider displays
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', (e) => {
                const valId = e.target.id.replace('-', '-val').replace('agents', 'val').replace('size', 'val').replace('cycles', 'val');
                document.getElementById(valId).textContent = e.target.value;
            });
        });

        function initializeSimulation() {
            N = parseInt(document.getElementById('n-agents').value);
            podSize = parseInt(document.getElementById('pod-size').value);
            Q = parseInt(document.getElementById('q-cycles').value);
            L = parseInt(document.getElementById('l-cycles').value);

            agents = [];
            edges = [];
            pods = [];
            cycle = 0;
            history = [];

            // Create agents
            for (let i = 0; i < N; i++) {
                agents.push({
                    id: i,
                    x: Math.random() * 560 + 20,
                    y: Math.random() * 560 + 20,
                    vx: 0,
                    vy: 0,
                    pc: 7,
                    presences: new Set(),
                    trust: {},
                    openLoops: [],
                    traces: {},
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`
                });
            }

            // Create overlapping pods
            const shuffled = [...agents].sort(() => Math.random() - 0.5);
            for (let i = 0; i < N; i += Math.max(1, podSize - 3)) {
                if (i + podSize > N) break;
                const pod = shuffled.slice(i, i + podSize).map(a => a.id);
                pods.push(pod);
                
                // Create edges within pod
                for (let j = 0; j < pod.length; j++) {
                    for (let k = j + 1; k < pod.length; k++) {
                        edges.push({ from: pod[j], to: pod[k], strength: 0.5 });
                    }
                }
            }

            drawNetwork();
            updateMetrics();
        }

        function isLoudPhase() {
            const within = cycle % (Q + L);
            return within >= Q;
        }

        function stepSimulation() {
            const loud = isLoudPhase();
            
            // Each agent interacts
            agents.forEach(agent => {
                const budget = loud ? agent.pc : Math.floor(agent.pc * 0.6);
                const neighbors = getNeighbors(agent.id);
                
                // Select neighbors based on trust
                neighbors.sort((a, b) => (agent.trust[b] || 0.5) - (agent.trust[a] || 0.5));
                const selected = neighbors.slice(0, budget);
                
                selected.forEach(nid => {
                    interact(agent, nid);
                });
                
                // Decay open loops
                agent.openLoops = agent.openLoops.filter(loop => {
                    loop.age++;
                    if (loop.age > 6) {
                        // Decay trust
                        loop.path.forEach(pid => {
                            agent.trust[pid] = Math.max(0, (agent.trust[pid] || 0.5) - 0.1);
                        });
                        return false;
                    }
                    return true;
                });
                
                // Age traces
                Object.keys(agent.traces).forEach(tid => {
                    agent.traces[tid] = agent.traces[tid].map(([age, str]) => [age + 1, str])
                        .filter(([age]) => Math.exp(-age / 20) > 0.01);
                    if (agent.traces[tid].length === 0) delete agent.traces[tid];
                });
            });

            cycle++;
            
            // Physics simulation for visualization
            applyForces();
            
            drawNetwork();
            updateMetrics();
            updatePhaseIndicator();
        }

        function getNeighbors(agentId) {
            return edges
                .filter(e => e.from === agentId || e.to === agentId)
                .map(e => e.from === agentId ? e.to : e.from);
        }

        function interact(agent, otherId) {
            const other = agents[otherId];
            if (!other) return;

            const quality = agent.presences.size > agent.pc ? 0.5 : 1.0;
            
            // Create traces
            if (!agent.traces[otherId]) agent.traces[otherId] = [];
            agent.traces[otherId].push([0, quality]);
            if (!other.traces[agent.id]) other.traces[agent.id] = [];
            other.traces[agent.id].push([0, quality]);
            
            // Reciprocity
            const loopIdx = other.openLoops.findIndex(l => l.origin === agent.id);
            if (loopIdx === -1) {
                agent.openLoops.push({ origin: agent.id, path: [agent.id, otherId], age: 0 });
            } else {
                other.openLoops.splice(loopIdx, 1);
            }
            
            // Update trust
            agent.trust[otherId] = Math.min(1, (agent.trust[otherId] || 0.5) + 0.02 * quality);
            other.trust[agent.id] = Math.min(1, (other.trust[agent.id] || 0.5) + 0.02 * quality);
            
            // Update presences
            agent.presences.add(otherId);
            
            // Update edge strength
            const edge = edges.find(e => 
                (e.from === agent.id && e.to === otherId) ||
                (e.to === agent.id && e.from === otherId)
            );
            if (edge) {
                edge.strength = Math.min(1, edge.strength + 0.05);
            }
        }

        function applyForces() {
            // Simple force-directed layout
            agents.forEach(a => {
                a.vx *= 0.8;
                a.vy *= 0.8;
                
                // Repulsion
                agents.forEach(b => {
                    if (a.id === b.id) return;
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                    const force = 100 / (dist * dist);
                    a.vx += (dx / dist) * force;
                    a.vy += (dy / dist) * force;
                });
                
                // Center gravity
                a.vx += (300 - a.x) * 0.001;
                a.vy += (300 - a.y) * 0.001;
            });
            
            // Attraction along edges
            edges.forEach(e => {
                const a = agents[e.from];
                const b = agents[e.to];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const force = (dist - 80) * 0.01 * e.strength;
                a.vx += (dx / dist) * force;
                a.vy += (dy / dist) * force;
                b.vx -= (dx / dist) * force;
                b.vy -= (dy / dist) * force;
            });
            
            agents.forEach(a => {
                a.x += a.vx;
                a.y += a.vy;
                a.x = Math.max(20, Math.min(580, a.x));
                a.y = Math.max(20, Math.min(580, a.y));
            });
        }

        function drawNetwork() {
            const canvas = document.getElementById('network-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 600, 600);
            
            // Draw edges
            edges.forEach(e => {
                const a = agents[e.from];
                const b = agents[e.to];
                ctx.strokeStyle = `rgba(100, 100, 100, ${e.strength * 0.3})`;
                ctx.lineWidth = e.strength * 2;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            });
            
            // Draw agents
            agents.forEach(a => {
                const size = 8 + (a.presences.size / 5);
                ctx.fillStyle = a.color;
                ctx.beginPath();
                ctx.arc(a.x, a.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function updateMetrics() {
            // Calculate metrics
            const pd = agents.reduce((sum, a) => sum + a.presences.size, 0) / agents.length;
            const ri = agents.filter(a => a.openLoops.length === 0).length / agents.length;
            
            let totalTraces = 0;
            let traceCount = 0;
            agents.forEach(a => {
                Object.values(a.traces).forEach(tlist => {
                    tlist.forEach(([age, str]) => {
                        totalTraces += Math.exp(-age / 20) * str;
                        traceCount++;
                    });
                });
            });
            const mr = traceCount > 0 ? totalTraces / traceCount : 0;
            
            const rb = 1 - Math.abs((Q / Math.max(1, L)) - 2.5) / 2.5;
            const sii = (pd / 14 + ri + mr + rb) / 4;
            
            document.getElementById('pd-val').textContent = pd.toFixed(1);
            document.getElementById('ri-val').textContent = ri.toFixed(2);
            document.getElementById('mr-val').textContent = mr.toFixed(2);
            document.getElementById('sii-val').textContent = sii.toFixed(2);
            
            history.push({ cycle, sii, phase: isLoudPhase() ? 'loud' : 'quiet' });
            if (history.length > 200) history.shift();
            
            drawChart();
        }

        function drawChart() {
            const canvas = document.getElementById('chart-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 1200, 200);
            
            if (history.length < 2) return;
            
            const margin = 40;
            const width = 1200 - 2 * margin;
            const height = 200 - 2 * margin;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, margin + height);
            ctx.lineTo(margin + width, margin + height);
            ctx.stroke();
            
            // Draw phase backgrounds
            const cycleWidth = width / history.length;
            history.forEach((h, i) => {
                if (h.phase === 'loud') {
                    ctx.fillStyle = 'rgba(245, 124, 0, 0.1)';
                    ctx.fillRect(margin + i * cycleWidth, margin, cycleWidth, height);
                }
            });
            
            // Draw SII line
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            history.forEach((h, i) => {
                const x = margin + (i / history.length) * width;
                const y = margin + height - (h.sii * height);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function updatePhaseIndicator() {
            const indicator = document.getElementById('phase-indicator');
            const loud = isLoudPhase();
            indicator.className = `phase-indicator phase-${loud ? 'loud' : 'quiet'}`;
            indicator.textContent = `Phase: ${loud ? 'LOUD' : 'QUIET'} (Cycle ${cycle})`;
        }

        function startSimulation() {
            if (!running) {
                if (cycle === 0) initializeSimulation();
                running = true;
                document.getElementById('start-btn').disabled = true;
                document.getElementById('pause-btn').disabled = false;
                animate();
            }
        }

        function pauseSimulation() {
            running = false;
            document.getElementById('start-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
            if (animationId) cancelAnimationFrame(animationId);
        }

        function resetSimulation() {
            pauseSimulation();
            initializeSimulation();
            document.getElementById('start-btn').disabled = false;
            cycle = 0;
        }

        function animate() {
            if (!running) return;
            stepSimulation();
            animationId = requestAnimationFrame(() => setTimeout(animate, 100));
        }

        // Initialize on load
        initializeSimulation();
    </script>
</body>
</html>